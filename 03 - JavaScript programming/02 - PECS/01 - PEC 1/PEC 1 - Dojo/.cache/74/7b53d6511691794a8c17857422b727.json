{"id":"index.html","dependencies":[{"name":"./styles.css","dynamic":true,"resolved":"/home/ansan/Documents/Master-Websites-Applications-UOC/03 - JavaScript programming/02 - PECS/01 - PEC 1/Katas/00 - Sumatorio/styles.css","parent":"/home/ansan/Documents/Master-Websites-Applications-UOC/03 - JavaScript programming/02 - PECS/01 - PEC 1/Katas/00 - Sumatorio/index.html"},{"name":"./index.js","dynamic":true,"resolved":"/home/ansan/Documents/Master-Websites-Applications-UOC/03 - JavaScript programming/02 - PECS/01 - PEC 1/Katas/00 - Sumatorio/index.js","parent":"/home/ansan/Documents/Master-Websites-Applications-UOC/03 - JavaScript programming/02 - PECS/01 - PEC 1/Katas/00 - Sumatorio/index.html"}],"generated":{"html":"<html>\n\n<head>\n    <title>Kata #0: sumatorio</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"/4e7bb40584b55a44f4657b188986bff4.css\">\n    <script src=\"/168726dbe96b3ce427e7fedce31bb0bc.js\"></script>\n</head>\n\n<body>\n    <main>\n        <h1> Kata #0: sumatorio</h1>\n        <p>Haremos este primer ejemplo paso a paso para que os resulte más sencillo enfocar los que vienen a\n            continuación:</p>\n        <p>\n            Primero debemos entender lo que se nos pide: ¿qué es la operación sumatorio? Vamos a simplificar el\n            sumatorio\n            matemático general al caso puntual de sumar todos sus valores consecutivos hasta llegar a 0, siendo 1 el\n            último\n            valor a sumar. Por ejemplo: sumatorio de 3 equivale a 3 + 2 + 1 = 6.\n        </p>\n        <p>\n            Abrimos nuestro proyecto de tooling y creamos una nueva carpeta para esta PEC1 junto con dos archivos:\n            kata0.js para la función sumatorio y kata0.spec.js para sus tests asociados.\n        </p>\n        <p>\n            Vamos a añadir un nuevo script para poder llevar a cabo tdd. Añadiremos estas lineas a nuestro fichero\n            package.json: \"test\": \"jest --passWithNoTests --silent\",\n        </p>\n        <p>\n            Este nuevo comando nos permitirá arrancar jest en modo watch para que vaya pasando los tests cada vez que\n            guardemos un fichero. Vamos a la consola y ejecutamos npm run tdd.\n        </p>\n        <p>\n            Jest se quedará en modo de espera a que empecemos a trabajar nuestros tests.\n        </p>\n        <p>\n            Ahora vamos a realizar un esfuerzo mental contra intuitivo. Vamos a implementar el primer test antes de\n            siquiera\n            tener la función. Como comentamos en la primera actividad TDD requiere que todos los tests escritos fallen\n            antes\n            de ser válidos en una siguiente iteración para verificar que cuando hay un error el test no pasa. En caso de\n            no\n            hacerlo así nunca sabríamos si los tests funcionan correctamente.\n        </p>\n        <p>\n            Este será nuestro primer test:\n        </p>\n        <code>\n            <pre>\n                describe('Kata #0: sumatorio', () => {\n                    test('de 0 es 0', () => {\n                        expect(sumatorio(0)).toBe(0);\n                    });\n                });\n            </pre>\n        </code>\n        <p>\n            Con el bloque <a href=\"https://jestjs.io/docs/en/api#describename-fn\">describe</a> creamos un bloque que\n            agrupa varios tests relacionados, en nuestro caso todos los de\n            la kata #0. Con el bloque test definiremos cada una de las condiciones que debe cumplir nuestra función, en\n            primer lugar tomaremos el caso más básico que es que el sumatorio de 0 debe ser 0.\n        </p>\n        <p>\n            El mensaje que recibimos obviamente es que la función sumatorio no está definida. Lógicamente este caso iba\n            a fallar pero está bien cometer este error para asegurarnos que a nivel estructural el código es correcto.\n        </p>\n        <p>\n            Ahora que tenemos un test que falla pasamos a corregirlo en la siguiente iteración:\n        </p>\n        <p>\n            Definimos la función sumatorio que toma un parámetro num y la exportamos como default del módulo. Se trata\n            de la firma de la función, de momento sin ninguna implementación:\n        </p>\n        <code>\n            <pre>\n                export default function sumatorio(num) {\n\n                }\n            </pre>\n        </code>\n        <p>\n            En el fichero de test importamos la función que acabamos de definir:\n        </p>\n        <code>\n            <pre>\n                import sumatorio from './kata0';\n            </pre>\n        </code>\n        <p>\n            Ahora el error que recibimos es diferente, ya no nos habla del problema de una función indefinida sino que\n            dicha función existe pero que no pasa el primer test.\n        </p>\n        <p>\n            La metodología TDD define que para desarrollar debemos implementar el código más sencillo que hace que el\n            test se cumpla. En nuestro caso sería algo similar a esto:\n        </p>\n        <p>Estoy seguro de que vais a pensar que es de perogrullo y que ese caso no cubre para nada lo que debe hacer la\n            función sumatorio pero TDD implica este ciclo: </p>\n        <ul>\n            <li>escribir un test que falle </li>\n            <li>escribir el mínimo código posible para que pase el test sin romper los anteriores</li>\n            <li>iterar y refactorizar para adecuar el código</li>\n        </ul>\n        <p>\n            El siguiente test será:\n        </p>\n        <code>\n            <pre>\n                test('de 1 es 1', () => {\n                    expect(sumatorio(1)).toBe(1);\n                });\n            </pre>\n        </code>\n        <p>\n            Obviamente este test no queda cubierto por nuestro código anterior así que añadimos el mínimo código para\n            hacer que se cumpla:\n        </p>\n        <code>\n            <pre>\n                export default function sumatorio(num) {\n                    return num;\n                }\n            </pre>\n        </code>\n        <p>\n            En este caso sabemos que los resultados son casualmente correctos en base a los argumentos recibidos de la\n            función. Estamos seguros de que no habrá más casos fantásticos como este (posiblemente) pero hemos seguido\n            el protocolo de TDD una vez más. Los tests vuelven a pasar.\n        </p>\n        <p>\n            Añadimos un tercer test (el primero que anticipamos realmente interesante):\n        </p>\n        <code>\n            <pre>\n                test('de 2 es 3', () => {\n                    expect(sumatorio(2)).toBe(3);\n                  });\n            </pre>\n        </code>\n        <p>\n            Ahora tendremos que repensar un poco más la función porque el test no pasa (en caso de pasar sería\n            redundante):\n        </p>\n        <code>\n            <pre>\n                export default function sumatorio(num) {\n                    if (num === 2) {\n                      return 3;\n                    }\n                  \n                    return num;\n                  }\n            </pre>\n        </code>\n        <p>\n            Vale. Estamos jugando sucio y lo sabemos. Hemos conseguido que los tests pasen pero nuestro código es\n            demasiado estático. A partir de ahora ya podemos intuir que cualquier caso adicional va a requerir de un\n            condicional y retornar un valor concreto que obviamente es un proceso que no escala ya que queremos que sea\n            automático en base al argumento. Vamos a intentar refactorizar el código para cubrir los tres casos actuales\n            antes de pasar al siguiente:\n        </p>\n        <code>\n            <pre>\n                export default function sumatorio(num) {\n                    let sumatorio = 0;\n                    let valorActual = num;\n                  \n                    while (valorActual !== 0) {\n                      sumatorio = sumatorio + valorActual;\n                      valorActual = valorActual - 1;\n                    }\n                  \n                    return sumatorio;\n                  }\n            </pre>\n        </code>\n        <p>\n            Esta es una solución muy verbosa y legible de una pieza de código que cubre los tres casos. Conociendo el\n            procedimiento matemático del sumatorio que hemos propuesto somos conscientes de que cualquier nuevo caso iba\n            a quedar cubierto. Añadamos un nuevo test:1\n        </p>\n        <code>\n            <pre>\n                test('de 3 es 6', () => {\n                    expect(sumatorio(3)).toBe(6);\n                  });\n            </pre>\n        </code>\n        <p>\n            Si pasamos los tests de nuevo vemos que queda cubierto con nuestro código actual por lo que no tiene sentido\n            añadir algo redundante así que lo borramos.\n        </p>\n        <p>\n            Otras implementaciones más sofisticadas podrían ser ésta que abusa del algoritmo matemático en lugar de un\n            proceder de casuísticas como ha sido nuestro desarrollo:\n        </p>\n        <code>\n            <pre>\n                export default function sumatorio(num) {\n                    return (num * (num + 1)) / 2;\n                  }\n            </pre>\n        </code>\n        <p>\n            O ésta que usa recursividad:\n        </p>\n        <code>\n            <pre>\n                export default function sumatorio(num) {\n                    return num ? num + sumatorio(num - 1) : 0;\n                  }\n            </pre>\n        </code>\n        <p>\n            Todas ellas válidas y con un rendimiento aproximadamente igual. Sin embargo a mi humilde entender, la\n            primera tiene una gran ventaja y es que no hace falta pensar mucho para entenderla lo cual es una gran\n            ventaja cuando se trabaja en equipo y hay que mantener una base de código grande. Contra más sencillo y\n            legible sea el código, mejor. Al menos, como reitero, desde mi muy personal punto de vista.\n        </p>\n        <p>\n            Este desarrollo nos da la seguridad que al trabajar con código modularizado esta parte siempre va a\n            funcionar correctamente y si en algún momento debemos modificarla o ampliarla ya tenemos los tests que nos\n            indicarán si los cambios introducidos rompen la plataforma.\n        </p>\n        <p>\n            Soy de la opinión de que muchos tests son innecesarios una vez tenemos práctica suficiente pero como modelo\n            y mecanismo mental es muy interesante exponeros a este paso a paso en las siguientes katas. Llegó vuestro\n            turno.\n        </p>\n        \n</main></body>\n\n</html>"},"sourceMaps":null,"error":null,"hash":"50bbbcbf2efeed2778f3366839243b82","cacheData":{}}